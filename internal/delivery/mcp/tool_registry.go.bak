package mcp

import (
	"context"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/FreePeak/cortex/pkg/server"

	"github.com/FreePeak/db-mcp-server/internal/usecase"
)

// ToolRegistry structure to handle tool registration
type ToolRegistry struct {
	server          *ServerWrapper
	mcpServer       *server.MCPServer
	databaseUseCase UseCaseProvider
	factory         *ToolTypeFactory
}

// NewToolRegistry creates a new tool registry
func NewToolRegistry(mcpServer *server.MCPServer) *ToolRegistry {
	factory := NewToolTypeFactory()
	return &ToolRegistry{
		server:    NewServerWrapper(mcpServer),
		mcpServer: mcpServer,
		factory:   factory,
	}
}

// RegisterAllTools registers all tools with the server
func (tr *ToolRegistry) RegisterAllTools(ctx context.Context, useCase UseCaseProvider) error {
	tr.databaseUseCase = useCase

	// Get available databases
	dbList := useCase.ListDatabases()
	if len(dbList) == 0 {
		log.Printf("No databases available, registering mock tools")
		return tr.RegisterMockTools(ctx)
	}

	// Register database-specific tools
	for _, dbID := range dbList {
		tr.registerDatabaseTools(ctx, dbID)
	}

	// Register common tools
	tr.registerCommonTools(ctx)

	// Register Cursor-compatible tool aliases
	tr.RegisterCursorCompatibleTools(ctx)

	return nil
}

// registerDatabaseTools registers all tools for a specific database
func (tr *ToolRegistry) registerDatabaseTools(ctx context.Context, dbID string) {
	// Get all tool types from the factory
	toolTypeNames := []string{
		"query", "execute", "transaction", "performance", "schema",
	}

	// Register each tool type for this database
	for _, typeName := range toolTypeNames {
		tr.registerTool(ctx, typeName, fmt.Sprintf("%s_%s", typeName, dbID), dbID)
	}

	log.Printf("Registered tools for database %s", dbID)
}

// registerTool registers a tool with the server
func (tr *ToolRegistry) registerTool(ctx context.Context, toolTypeName string, name string, dbID string) error {
	log.Printf("Registering tool '%s' of type '%s' (database: %s)", name, toolTypeName, dbID)

	toolTypeImpl, ok := tr.factory.GetToolType(toolTypeName)
	if !ok {
		return fmt.Errorf("failed to get tool type for '%s'", toolTypeName)
	}

	tool := toolTypeImpl.CreateTool(name, dbID)

	return tr.server.AddTool(ctx, tool, func(ctx context.Context, request server.ToolCallRequest) (interface{}, error) {
		return toolTypeImpl.HandleRequest(ctx, request, dbID, tr.databaseUseCase)
	})
}

// registerCommonTools registers tools that are not specific to a database
func (tr *ToolRegistry) registerCommonTools(ctx context.Context) {
	// Register the list_databases tool
	_, ok := tr.factory.GetToolType("list_databases")
	if ok {
		tr.registerTool(ctx, "list_databases", "list_databases", "")
	}
}

// RegisterCursorCompatibleTools registers aliases for all tools with Cursor-compatible naming
func (tr *ToolRegistry) RegisterCursorCompatibleTools(ctx context.Context) {
	prefix := getToolNamePrefix()

	// Get all registered databases
	databases := tr.databaseUseCase.ListDatabases()

	// For each database and tool type, create a cursor-compatible alias
	for _, dbID := range databases {
		for _, toolType := range []string{"query", "execute", "transaction", "performance", "explain", "schema"} {
			sourceName := fmt.Sprintf("%s_%s", dbID, toolType)
			targetName := fmt.Sprintf("%s_%s_%s", prefix, dbID, toolType)

			// Register the alias tool
			tr.createToolAlias(ctx, toolType, sourceName, targetName)
		}
	}

	// Don't forget the list_databases tool
	listDbSource := "list_databases"
	listDbTarget := fmt.Sprintf("%s_list_databases", prefix)
	tr.createToolAlias(ctx, "list_databases", listDbSource, listDbTarget)

	log.Printf("Registered cursor-compatible aliases with prefix '%s' for all tools", prefix)
}

// createToolAlias creates an alias for an existing tool
func (tr *ToolRegistry) createToolAlias(ctx context.Context, toolTypeName string, existingName string, aliasName string) error {
	log.Printf("Creating alias '%s' for tool '%s' of type '%s'", aliasName, existingName, toolTypeName)

	toolTypeImpl, ok := tr.factory.GetToolType(toolTypeName)
	if !ok {
		return fmt.Errorf("failed to get tool type for '%s'", toolTypeName)
	}

	// For aliases that apply to a specific database, extract the dbID from the existing name
	// This is a simplification - in a real implementation we'd have to look up the actual dbID
	dbID := ""

	// Create a new tool with the alias name but delegate to the original handler
	tool := toolTypeImpl.CreateTool(aliasName, dbID)

	return tr.server.AddTool(ctx, tool, func(ctx context.Context, request server.ToolCallRequest) (interface{}, error) {
		return toolTypeImpl.HandleRequest(ctx, request, dbID, tr.databaseUseCase)
	})
}

// getToolNamePrefix returns the prefix to use for Cursor-compatible tool names
func getToolNamePrefix() string {
	// Default prefix (same as in previous versions)
	defaultPrefix := "mcp_cashflow_db_mcp_server_sse"

	// Check if a custom prefix is defined in environment variable
	customPrefix := os.Getenv("MCP_TOOL_PREFIX")
	if customPrefix != "" {
		return customPrefix
	}

	return defaultPrefix
}

// RegisterMockTools registers mock tools with the server when no db connections available
func (tr *ToolRegistry) RegisterMockTools(ctx context.Context) error {
	log.Printf("Registering mock tools")

	// For each tool type, register a mock tool
	for toolTypeName, _ := range tr.factory.toolTypes {
		mockToolName := fmt.Sprintf("mock_%s", toolTypeName)

		toolTypeImpl, ok := tr.factory.GetToolType(toolTypeName)
		if !ok {
			log.Printf("Failed to get tool type for '%s'", toolTypeName)
			continue
		}

		tool := toolTypeImpl.CreateTool(mockToolName, "mock")

		err := tr.server.AddTool(ctx, tool, func(ctx context.Context, request server.ToolCallRequest) (interface{}, error) {
			return toolTypeImpl.HandleRequest(ctx, request, "mock", tr.databaseUseCase)
		})

		if err != nil {
			log.Printf("Failed to register mock tool '%s': %v", mockToolName, err)
			continue
		}

		// Create cursor-compatible alias for the mock tool
		cursorName := mockToolName
		if strings.HasPrefix(toolTypeName, "database_") {
			cursorName = strings.TrimPrefix(toolTypeName, "database_")
		}

		if cursorName != mockToolName {
			err = tr.createToolAlias(ctx, toolTypeName, mockToolName, cursorName)
			if err != nil {
				log.Printf("Failed to create cursor alias for mock tool '%s': %v", mockToolName, err)
			}
		}
	}

	return nil
}
